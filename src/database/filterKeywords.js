import db, { query, execute, getOne } from './db';

// –≠—Ç–∏ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –ø–µ—Ä–≤–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏.
const INITIAL_KEYWORDS = [
    // Positive Emojis
    ...['ü•í', 'üçÜ', 'ü•¶', '‚úÖ', 'üü¢', '‚õîÔ∏è', '‚òÄÔ∏è', 'üò°', 'üåº', 'ü´í', 'üü•', 'üö®', 'üõë', 'üåû', 'üëå', '‚ùå', 'ü™Ä', 'üå≥', 'üëπ', 'üíö', 'ü§¨', 'üß∂', 'üåµ', 'üöì', 'üöß', 'üê∏', 'üëÆ‚Äç‚ôÇ'].map(k => ({ keyword: k, type: 'positive_emoji', is_regex: 0 })),

    // Positive Words
    ...['–≥—Ä—è–∑–Ω–æ', '–≥—Ä—è–∑—å', '–∫—Ä–µ–ø—è—Ç', '–∫—Ä–µ–ø—è—Ç—å', '–Ø–º—ã', '–¢—É—á–∏', '—á–∏—Å—Ç–æ', '—á–∏—Å—Ç–æ—Ç–∞', '—á–∏—Å—Ç', '—á–∏—Å—Ç—ã–π', '—á–∏–∑—Ç', '—Ç–∏—Ö–æ', '–Ω–æ—Ä–º', '–≤ –Ω–æ—Ä–º–µ', '–æ–∫', 'ok', '–æ–ª–∏–≤–æ–∫', '–æ–ª–∏–≤–∫–∏', '–æ–ª–∏–≤–∫–∞–º–∏', '–∑–µ–ª–µ–Ω—ã—Ö', '–∑–µ–ª–µ–Ω—å', '–∑–µ–ª–µ–Ω–∏', '—Å–∏–Ω–∏–µ', '—Å–∏–Ω–∏—Ö', '—É—Ö–∏–ª—è–Ω—Ç', '–ø–∏–∫—Å–µ–ª—è', '—á–µ—Ä–Ω—ã–µ', '–º—É—Å–æ—Ä–∞', '–ø–∏–¥–∞—Ä—ã', '–ø—Ä–æ–≤–µ—Ä—è—é—Ç', '—É–ø–∞–∫–æ–≤–∞–ª–∏', '–ø—Ä–µ—Å—É—é—Ç', '–ø—Ä–µ—Å—É—é—Ç—å', '–ø–∞–∫—É—é—Ç', '–∫–∞—Ç–∞—é—Ç—Å—è', '–ø—Ä–æ–≤–µ—Ä–∫–∞', '–ø–µ—à–∏–µ', '–≤–Ω–∏–º–∞–Ω–∏–µ', '–æ—Å—Ç–æ—Ä–æ–∂–Ω–æ', '–ø–∞—Ç—Ä—É–ª—å', '–ø–∞—Ç—Ä—É–ª—å–∫–∞', '—Ç—Ü–∫', '–∫–æ–ø—ã', '—Ç—Ä—É–∫–∞–º', '—Ç—Ä—É–±–∫–∞–º', '–ª—é—Å—Ç—Ä–∞', '–ª—é—Å—Ç—Ä—ã', '–±–ø', '—á–µ—Ä—Ç–∏', '–≥–Ω–∏–ª–∏', '–≥–Ω–∏–ª—å', '–≤–æ–ª–≥–∞', '–Ω–∏–≤–∞', '–Ω—ñ–≤–∞', '–Ω—ñ–≤–µ', '–Ω–∏–≤–µ', '–±—É—Å', '–¥–µ–≤—è—Ç–∫–∞', '–∞–º—É–ª–µ—Ç', '—Ñ–æ—Ä–¥', '—Å–ø—Ä–∏–Ω—Ç–µ—Ä', '—Ç—Ä–∞–Ω–∑—ñ—Ç', '—Ç—Ä–∞–Ω–∑–∏—Ç', '–ø–∏—Ä–æ–∂–æ–∫'].map(k => ({ keyword: k, type: 'positive_word', is_regex: 0 })),

    // Positive Regex
    ...['–Ω–∞[\\s]+–≤–æ–µ–Ω–Ω—ã—Ö[\\s]+–Ω–æ–º–µ—Ä–∞—Ö', '6778', '–≤–æ–∏–Ω—ã[\\s]+–¥–æ–±—Ä–∞'].map(k => ({ keyword: k, type: 'positive_word', is_regex: 1 })),

    // Negative Keywords (–ø—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤—Ö–æ–∂–¥–µ–Ω–∏–µ)
    ...['?', '¬ø', '—Å—ä–µ–±—ë—Ç—Å—è'].map(k => ({ keyword: k, type: 'negative_keyword', is_regex: 0 })),

    // Negative Words
    ...['–±–ª—è', '–∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ', '–∞ –∫–∞–∫–æ–π', '–≤ –∞—Ö—É–µ', '–ø–æ—Ö', '–µ—Å–ª–∏', '—á–µ–≤–æ', '—á–µ–≥–æ', '—à–æ—Ç–∞–∫', '–Ω–∞—Ö—É–π', '–±–ª—ç—Ç', '–≤–∞–π–±', '–ø–æ—á–µ–º—É', '–¥–æ–ª–±–æ–µ–±', '–¥–∞–ª–±–∞–µ–±', '—Ö—É–π', '–ø–∏–¥–∞—Ä', '–≤–æ–±—â–µ–º', '–º–µ–Ω—è', '–¥–æ–ª–≥–æ', '–∑–Ω–∞–∫–æ–º–æ–≥–æ', '–≥–æ–≤–æ—Ä–∏–ª–∏', '–º–Ω–µ', '–∑–∞–µ–±–∞–ª', '–∫–∞–∂–¥–æ–º—É', '—á—É–≤—Å—Ç–≤–æ–≤–∞–ª', '–±–µ–∂–∞—Ç—å', '–¥–ª—è', '–¥–∞–∂–µ', '—Ñ–∏–ª—å–º', '–∞–∫—Ç—ë—Ä—ã', '–±—É–¥—É[\\s]–∑–Ω–∞—Ç—å', '–≤–∞—Ä–∏–∞–Ω—Ç', '—Ä–∞–∑–≤–ª–µ–∫–∞–π—Å—è', '–ø–µ—Ä–µ—Ä–≤–∞', '–ø–∏–≤–æ', '–≤–æ–¥–∫–∞', '–≤–æ–¥–∫–∏', '—Ç—ã', '–¥–æ–≥–æ–≤–æ—Ä', '—Ñ—É—Ö'].map(k => ({ keyword: k, type: 'negative_word', is_regex: 0 })),

    // Negative Regex
    ...['–ø–æ—Ç–æ–º—É[\\s]—á—Ç–æ', '–ø–µ—Ä–µ–¥[\\s]—Ç–µ–º'].map(k => ({ keyword: k, type: 'negative_word', is_regex: 1 })),
];


export const initializeFilterKeywordsDatabase = () => {
    execute(`
        CREATE TABLE IF NOT EXISTS filter_keywords (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            keyword TEXT NOT NULL UNIQUE,
            type TEXT NOT NULL CHECK(type IN ('positive_emoji', 'positive_word', 'negative_keyword', 'negative_word')),
            is_regex BOOLEAN NOT NULL DEFAULT 0
        )
    `);

    const keywordCount = getOne('SELECT COUNT(*) as count FROM filter_keywords')?.count;

    if (keywordCount === 0) {
        console.log('Populating filter_keywords table with initial data...');

        const insert = db.prepare('INSERT INTO filter_keywords (keyword, type, is_regex) VALUES (?, ?, ?)');

        const insertMany = db.transaction((items) => {
            for (const item of items) {
                try {
                    insert.run(item.keyword, item.type, Number(item.is_regex));
                } catch (error) {
                    // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏, –µ—Å–ª–∏ –≤ –∏—Å—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –µ—Å—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã
                    if (!error.message.includes('UNIQUE constraint failed')) {
                        console.error(`Failed to insert keyword: ${item.keyword}`, error);
                        throw error;
                    }
                }
            }
        });

        try {
            insertMany(INITIAL_KEYWORDS);
            console.log('filter_keywords table populated successfully.');
        } catch (error) {
            console.error('Error populating filter_keywords table:', error);
        }
    }
};

/**
 * –ü–æ–ª—É—á–∞–µ—Ç –≤—Å–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.
 * –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞, —Ç–∞–∫ –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç better-sqlite3.
 * @returns {{
 *  positiveEmojis: Set<string>,
 *  positiveWords: string[],
 *  positiveRegex: string[],
 *  negativeKeywords: Set<string>,
 *  negativeWords: string[],
 *  negativeRegex: string[]
 * }} –û–±—ä–µ–∫—Ç —Å –∫–ª—é—á–µ–≤—ã–º–∏ —Å–ª–æ–≤–∞–º–∏, —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –ø–æ —Ç–∏–ø—É.
 */
export const getFilterKeywords = () => {
    const rows = query('SELECT keyword, type, is_regex FROM filter_keywords');

    const keywords = {
        positiveEmojis: new Set(),
        positiveWords: [],
        positiveRegex: [],
        negativeKeywords: new Set(),
        negativeWords: [],
        negativeRegex: [],
    };

    for (const row of rows) {
        switch (row.type) {
            case 'positive_emoji':
                keywords.positiveEmojis.add(row.keyword);
                break;
            case 'positive_word':
                row.is_regex ? keywords.positiveRegex.push(row.keyword) : keywords.positiveWords.push(row.keyword);
                break;
            case 'negative_keyword':
                keywords.negativeKeywords.add(row.keyword);
                break;
            case 'negative_word':
                row.is_regex ? keywords.negativeRegex.push(row.keyword) : keywords.negativeWords.push(row.keyword);
                break;
        }
    }
    return keywords;
};

/**
 * –ü–æ–ª—É—á–∞–µ—Ç –≤—Å–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –≤ –≤–∏–¥–µ –º–∞—Å—Å–∏–≤–∞ –æ–±—ä–µ–∫—Ç–æ–≤.
 * @returns {Array<Object>}
 */
export const getAllFilterKeywords = () => {
    return query('SELECT * FROM filter_keywords ORDER BY type, keyword');
};

/**
 * –î–æ–±–∞–≤–ª—è–µ—Ç –Ω–æ–≤–æ–µ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö.
 * @param {{keyword: string, type: string, is_regex: number}} data
 * @returns {import('better-sqlite3').RunResult}
 */
export const addFilterKeyword = ({ keyword, type, is_regex = 0 }) => {
    if (!keyword || !type) {
        throw new Error('Keyword and type are required.');
    }
    try {
        return execute(
            'INSERT INTO filter_keywords (keyword, type, is_regex) VALUES (?, ?, ?)',
            [keyword.trim(), type, is_regex]
        );
    } catch (error) {
        if (error.message.includes('UNIQUE constraint failed')) {
            const err = new Error(`Keyword "${keyword}" already exists.`);
            err.code = 'SQLITE_CONSTRAINT_UNIQUE';
            throw err;
        }
        throw error;
    }
};

export const deleteFilterKeyword = (id) => {
    if (!id) throw new Error('ID is required to delete a keyword.');
    return execute('DELETE FROM filter_keywords WHERE id = ?', [id]);
};
